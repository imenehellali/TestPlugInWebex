<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Placetel AI ‚Äì Call Transcripts</title>
  <script src="https://unpkg.com/@webex/embedded-app-sdk@latest"></script>
  <link rel="stylesheet" href="/static/app.css">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body class="page">
  <div class="topbar">
    <button id="tabLive" class="tab tab--active">Live</button>
    <button id="tabHist" class="tab">History</button>
    <div id="userInfo" style="margin-left: auto; color: #cfe4ff; font-size: 12px;"></div>
  </div>

  <div class="container">
    <!-- Authentication Status -->
    <div id="authStatus" class="card" style="display: none;">
      <div id="authMessage">üîê Authenticating...</div>
    </div>

    <!-- Live view -->
    <section id="viewLive" class="card">
      <header class="livehdr">
        <div class="livehdr__title" id="liveHeader"></div>
        <div class="livehdr__sub" id="liveSub"></div>
        <div class="badge">Live</div>
        <div id="liveEq" class="eq eq--hidden" aria-hidden="true">
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
        </div>
      </header>

      <!-- Transcript panel -->
      <div id="liveTx" class="tx hidden"></div>

      <!-- Idle bot -->
      <div id="liveIdle" class="empty">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div id="idleText">AI patiently waiting for calls.</div>
      </div>

      <div id="noLiveTx" class="info hidden">Warten auf Live-Transcript...</div>
    </section>

    <!-- History view -->
    <section id="viewHist" class="hidden">
      <div id="histWrap"></div>
      <div id="histEmpty" class="empty hidden">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div>No history yet‚Ä¶</div>
      </div>
    </section>
  </div>

  <script>
    // ========== AUTHENTICATION ==========
    let webexApp = null;
    let webexToken = null;
    let socket = null;
    let authenticated = false;

    (async function initWebex() {
      try {
        console.log('üîê Initializing Webex SDK...');
        
        if (!window.webex || !window.webex.Application) {
          console.error('‚ùå Webex SDK not loaded');
          showAuthError('Webex SDK not available. Please open in Webex.');
          return;
        }

        webexApp = new window.webex.Application();
        await webexApp.onReady();
        await webexApp.listen();
        
        console.log('‚úÖ Webex SDK ready');

        try {
          const context = await webexApp.context.getUser();
          document.getElementById('userInfo').textContent = 
            `üë§ ${context.displayName || context.email || 'User'}`;
        } catch (e) {
          console.warn('‚ö†Ô∏è Could not get user context:', e);
        }

        try {
          webexToken = await webexApp.context.getAccessToken();
          console.log('‚úÖ Got access token');
        } catch (e) {
          console.error('‚ùå Could not get access token:', e);
          showAuthError('Failed to get Webex access token');
          return;
        }

        connectSocket();
        setupCallListener();

      } catch (error) {
        console.error('‚ùå Webex init error:', error);
        showAuthError('Failed to initialize Webex: ' + error.message);
      }
    })();

    function connectSocket() {
      console.log('üîå Connecting to Socket.IO...');
      
      socket = io({
        transports: ['websocket', 'polling']
      });

      socket.on('connect', () => {
        console.log('üîå Socket connected, authenticating...');
        showAuthStatus('Authenticating with Webex...');
        
        socket.emit('authenticate', {
          webex_access_token: webexToken
        });
      });

      socket.on('authenticated', (data) => {
        console.log('‚úÖ Authenticated as:', data.email);
        authenticated = true;
        hideAuthStatus();
        setupCallEventListener();
      });

      socket.on('auth_failed', (data) => {
        console.error('‚ùå Authentication failed:', data.error);
        showAuthError('Authentication failed: ' + data.error);
      });

      socket.on('disconnect', () => {
        console.log('üîå Socket disconnected');
        authenticated = false;
        showAuthStatus('Disconnected. Reconnecting...');
      });

      socket.on('connect_error', (error) => {
        console.error('‚ùå Connection error:', error);
        showAuthError('Connection failed: ' + error.message);
      });
    }

    function showAuthStatus(message) {
      const status = document.getElementById('authStatus');
      const msg = document.getElementById('authMessage');
      msg.textContent = 'üîê ' + message;
      status.style.display = 'block';
      status.style.background = '#d1ecf1';
      status.style.color = '#0c5460';
    }

    function hideAuthStatus() {
      document.getElementById('authStatus').style.display = 'none';
    }

    function showAuthError(message) {
      const status = document.getElementById('authStatus');
      const msg = document.getElementById('authMessage');
      msg.textContent = '‚ùå ' + message;
      status.style.display = 'block';
      status.style.background = '#f8d7da';
      status.style.color = '#721c24';
    }

    function setupCallListener() {
      const lastKey = new Map();

      function getRemoteNumber(call = {}) {
        const rps = Array.isArray(call.remoteParticipants)
          ? call.remoteParticipants
          : (call.remoteParticipant ? [call.remoteParticipant] : []);
        
        const rp = rps[0];
        return rp?.phoneNumber || rp?.callerID || call.caller?.phoneNumber || '';
      }

      function getLocalNumber(call = {}) {
        return call.localParticipant?.phoneNumber || 
               call.localParticipant?.callerID ||
               call.to?.phoneNumber || '';
      }

      webexApp.on('sidebar:callStateChanged', (call) => {
        const state = (call?.state || '').toLowerCase();
        const remoteNumber = getRemoteNumber(call);
        const localNumber = getLocalNumber(call);
        const displayName = call.remoteParticipants?.[0]?.name || call.displayName || '';

        const key = [state, remoteNumber, localNumber].join('|');
        if (lastKey.get(call.id) === key) return;
        lastKey.set(call.id, key);

        console.log(`üìû Call ${state}: remote=${remoteNumber}, local=${localNumber}`);

        fetch('/simulate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            event: state,
            call_id: call.id,
            remoteNumber,
            localNumber,
            displayName
          })
        }).catch((err) => {
          console.error('‚ùå Failed to send call event:', err);
        });
      });
    }

    // ========== UI LOGIC ==========
    const tabLive = document.getElementById('tabLive');
    const tabHist = document.getElementById('tabHist');
    const viewLive = document.getElementById('viewLive');
    const viewHist = document.getElementById('viewHist');
    const liveHeader = document.getElementById('liveHeader');
    const liveSub = document.getElementById('liveSub');
    const liveTx = document.getElementById('liveTx');
    const liveIdle = document.getElementById('liveIdle');
    const idleText = document.getElementById('idleText');
    const liveEq = document.getElementById('liveEq');
    const noLiveTx = document.getElementById('noLiveTx');

    let activeCalls = new Set();
    let hasTranscript = false;

    function showLive() {
      tabLive.classList.add('tab--active');
      tabHist.classList.remove('tab--active');
      viewLive.classList.remove('hidden');
      viewHist.classList.add('hidden');
    }

    function showHist() {
      tabHist.classList.add('tab--active');
      tabLive.classList.remove('tab--active');
      viewHist.classList.remove('hidden');
      viewLive.classList.add('hidden');
    }

    tabLive.addEventListener('click', showLive);
    tabHist.addEventListener('click', showHist);

    function escapeHtml(s) {
      return String(s ?? '').replace(/[&<>"']/g, c => 
        ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'}[c]));
    }

    function initStructuredCard({ name = '‚Äî', number = '‚Äî', email = '‚Äî', agent = '‚Äî' } = {}) {
      liveTx.innerHTML = `
<div class="tx-card">
<div class="tx-grid">
<div class="tx-field">
  <div class="tx-label">Kunde</div>
  <div id="fldName" class="tx-value">${escapeHtml(name)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">R√ºckrufnummer</div>
  <div id="fldNumber" class="tx-value">${escapeHtml(number)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">Email</div>
  <div id="fldEmail" class="tx-value">${escapeHtml(email)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">Agent</div>
  <div id="fldAgent" class="tx-value">${escapeHtml(agent)}</div>
</div>
<div class="tx-field tx-section">
  <div class="tx-label">Anliegen</div>
  <ul id="listConcerns" class="tx-list"></ul>
</div>
<div class="tx-field tx-section">
  <div class="tx-label">Tasks</div>
  <ul id="listTasks" class="tx-list"></ul>
</div>
</div>
</div>
`;
    }

    function setIdle(show) {
      if (show) {
        liveIdle.classList.remove('hidden');
        liveTx.classList.add('hidden');
        noLiveTx.classList.add('hidden');
        liveEq.classList.add('eq--hidden');
        liveHeader.textContent = '';
        liveSub.textContent = '';
        idleText.textContent = 'AI patiently waiting for calls.';
        hasTranscript = false;
      } else {
        liveIdle.classList.add('hidden');
      }
    }

    function addConcernLines(text) {
      if (!text || !text.trim()) return;

      const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
      const concerns = [];
      const tasks = [];
      let currentSection = null;

      for (const line of lines) {
        const lower = line.toLowerCase();
        if (lower.includes('kunde:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldName').textContent = val;
        } else if (lower.includes('r√ºckrufnummer:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldNumber').textContent = val;
        } else if (lower.includes('email:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldEmail').textContent = val;
        } else if (lower.includes('agent:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldAgent').textContent = val;
        } else if (lower === 'anliegen:') {
          currentSection = 'concerns';
        } else if (lower === 'tasks:') {
          currentSection = 'tasks';
        } else if (line.startsWith('- ')) {
          const content = line.substring(2);
          if (currentSection === 'concerns') concerns.push(content);
          else if (currentSection === 'tasks') tasks.push(content);
        }
      }

      const listConcerns = document.getElementById('listConcerns');
      const listTasks = document.getElementById('listTasks');
      if (listConcerns) {
        listConcerns.innerHTML = '';
        concerns.forEach(c => {
          const li = document.createElement('li');
          li.textContent = c;
          listConcerns.appendChild(li);
        });
      }
      if (listTasks) {
        listTasks.innerHTML = '';
        tasks.forEach(t => {
          const li = document.createElement('li');
          li.textContent = t;
          listTasks.appendChild(li);
        });
      }
    }

    function setupCallEventListener() {
      socket.on('call_event', async (p) => {
        const state = (p.state || '').toLowerCase();
        const remoteNumber = p.remoteNumber || '';
        const displayName = p.displayName || '';
        const transcript = p.transcript || '';
        const callId = p.call_id;

        console.log(`üìû Event: ${state}, caller: ${remoteNumber}, hasTranscript: ${!!transcript}`);

        liveHeader.textContent = remoteNumber || displayName || '';
        liveSub.textContent = `State: ${state}`;

        // REQ #9: Call ended - return to idle
        if (state === 'ended') {
          console.log('‚òéÔ∏è Call ended');
          activeCalls.delete(callId);
          hasTranscript = false;
          
          if (activeCalls.size === 0) {
            setIdle(true);
          }
          return;
        }

        activeCalls.add(callId);

        // REQ #7: Ringing - show caller with idle bot
        if (state === 'ringing' || state === 'connecting') {
          console.log('üìû Ringing - idle bot + equalizer');
          
          liveIdle.classList.remove('hidden');
          liveEq.classList.remove('eq--hidden');
          idleText.textContent = `Incoming call from ${remoteNumber}...`;
          
          liveTx.classList.add('hidden');
          noLiveTx.classList.add('hidden');
          hasTranscript = false;
          
          return;
        }

        // REQ #8: Connected - show transcript or waiting
        if (state === 'connected') {
          if (transcript && transcript.trim()) {
            console.log('‚úÖ Transcript - switching to card');
            hasTranscript = true;
            
            liveIdle.classList.add('hidden');
            noLiveTx.classList.add('hidden');
            liveEq.classList.remove('eq--hidden');
            
            if (liveTx.classList.contains('hidden')) {
              initStructuredCard({
                name: displayName || '‚Äî',
                number: remoteNumber || '‚Äî',
                email: '‚Äî',
                agent: '‚Äî'
              });
            }
            
            liveTx.classList.remove('hidden');
            addConcernLines(transcript);
            
          } else {
            console.log('‚è≥ No transcript');
            liveIdle.classList.add('hidden');
            liveTx.classList.add('hidden');
            liveEq.classList.remove('eq--hidden');
            noLiveTx.classList.remove('hidden');
          }
        }
      });
    }

    setIdle(true);

  </script>
</body>
</html>
