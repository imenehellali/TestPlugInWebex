<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Placetel AI – Calls</title>
  <!-- head additions -->
  <script src="https://unpkg.com/@webex/embedded-app-sdk@latest"></script>
  <link rel="stylesheet" href="/static/app.css">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    /* optional quick mapping for name-over-number */
    window.CONTACTS = {
      "+4922197590844": "Imen Hellali",
      "+4930123456": "Maximilian Mustermann"
    };
  </script>
</head>
<script>
  (async function () {
    if (!window.webex || !window.webex.Application) return;
    const app = new window.webex.Application();
    try {
      await app.onReady();
      await app.listen();
      const last = new Map();

      function pickCaller(call) {
        // Try multiple fields; Webex Calling can vary by client/version
        const raw =
          call?.caller?.phoneNumber ||
          call?.caller?.id ||
          call?.remoteParticipant?.callerID ||
          call?.localParticipant?.callerID ||
          call?.caller?.name ||
          call?.displayName ||
          '';

        // Optional pretty mapping to a contact name
        const mapped = (window.CONTACTS && window.CONTACTS[raw]) ? `${window.CONTACTS[raw]} (${raw})` : raw;
        return mapped || 'Unknown';
      }

      app.on('sidebar:callStateChanged', (call) => {
        const state = (call.state || '').toLowerCase();
        const number = call.caller?.phoneNumber || call.caller?.callerID || '';
        const name = call.caller?.name || '';
        const caller = name && number ? `${name} (${number})` : (name || number || '');

        fetch('/simulate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ event: state, call_id: call.id, caller })
        }).catch(() => { });
      });
    } catch { }
  })();
</script>

<body class="page">
  <div class="topbar">
    <button id="tabLive" class="tab tab--active">Live</button>
    <button id="tabHist" class="tab">History</button>
  </div>

  <div class="container">
    <!-- Live view -->
    <section id="viewLive" class="card">
      <header class="livehdr">
        <div class="livehdr__title" id="liveHeader">+49 xxx xxx xxx</div>
        <div class="livehdr__sub" id="liveSub">Waiting for call…</div>
        <div class="badge">Live</div>
      </header>

      <div id="liveTx" class="tx hidden"></div>

      <!-- skeleton placeholder (visible until the first transcript arrives) -->
      <div id="txSkeleton" class="skeleton">
        <div class="skeleton__line"></div>
        <div class="skeleton__line skeleton__line--w80"></div>
        <div class="skeleton__line skeleton__line--w60"></div>
      </div>

      <!-- idle state (no active calls) -->
      <div id="liveIdle" class="empty hidden">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div> AI patiently waiting for calls.</div>
      </div>

      <div id="noLiveTx" class="info hidden">
        Live transcription is not being sent. Enable your AI pipeline or Webex transcription to populate this panel in
        real time.
      </div>
    </section>

    <!-- History view -->
    <section id="viewHist" class="hidden">
      <div id="histWrap"></div>
      <div id="histEmpty" class="empty hidden">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div>No history yet…</div>
      </div>
    </section>
  </div>

  <script>
    // Tabs
    const tabLive = document.getElementById('tabLive');
    const tabHist = document.getElementById('tabHist');
    const viewLive = document.getElementById('viewLive');
    const viewHist = document.getElementById('viewHist');

    function showLive() {
      tabLive.classList.add('tab--active');
      tabHist.classList.remove('tab--active');
      viewLive.classList.remove('hidden');
      viewHist.classList.add('hidden');
    }
    function showHist() {
      tabHist.classList.add('tab--active');
      tabLive.classList.remove('tab--active');
      viewHist.classList.remove('hidden');
      viewLive.classList.add('hidden');
      loadHistory();
    }
    tabLive.addEventListener('click', showLive);
    tabHist.addEventListener('click', showHist);

    // Live wiring
    const liveHeader = document.getElementById('liveHeader');
    const liveSub = document.getElementById('liveSub');
    const liveTx = document.getElementById('liveTx');
    const liveIdle = document.getElementById('liveIdle');
    const noLiveTx = document.getElementById('noLiveTx');
    const txSkeleton = document.getElementById('txSkeleton');

    let activeCalls = new Set();
    let sawLiveText = false;

    function setIdle(show) {
      liveIdle.classList.toggle('hidden', !show);
      liveTx.classList.toggle('hidden', show);
      txSkeleton.classList.toggle('hidden', show || sawLiveText);
      if (show) {
        liveHeader.textContent = '';
        liveSub.textContent = 'Waiting for call…';
        liveTx.textContent = '';
        sawLiveText = false;
        noLiveTx.classList.add('hidden');
      }
    }
    setIdle(true);

    const socket = io();
    socket.on('call_event', p => {
      const pretty = (window.CONTACTS && window.CONTACTS[p.caller])
        ? `${window.CONTACTS[p.caller]} (${p.caller})`
        : (p.caller || 'Unknown');
      liveHeader.textContent = pretty;

      if (p.state === 'ended') {
        activeCalls.delete(p.call_id);
        setIdle(activeCalls.size === 0);
        return;
      }

      activeCalls.add(p.call_id);
      setIdle(false);
      liveSub.textContent = `State: ${p.state}`;

      if (p.transcript && p.transcript.trim()) {
        sawLiveText = true;
        txSkeleton.classList.add('hidden');
        liveTx.classList.remove('hidden');
        liveTx.textContent = (liveTx.textContent ? liveTx.textContent + '\n' : '') + p.transcript;
      } else if (!sawLiveText) {
        noLiveTx.classList.remove('hidden');
      }
    });

    // History
    async function loadHistory() {
      const wrap = document.getElementById('histWrap');
      const empty = document.getElementById('histEmpty');
      wrap.innerHTML = ''; empty.classList.add('hidden');

      // pull the user’s last ~20 items (placed/missed/received)
      const hist = await (await fetch('/api/calls/history')).json();
      const byCaller = new Map(); // number/name -> items[]

      for (const rec of (hist.items || [])) {
        const label = rec.name?.trim() || rec.number || 'Unknown';
        if (!byCaller.has(label)) byCaller.set(label, []);
        byCaller.get(label).push(rec);
      }
      if (!byCaller.size) { empty.classList.remove('hidden'); return; }

      // newest first
      for (const rec of arr.sort((a, b) => String(b.time).localeCompare(String(a.time)))) {
        const it = document.createElement('div'); it.className = 'item';
        const meta = document.createElement('div'); meta.className = 'meta';
        meta.textContent = `${rec.type} | ${rec.time}`;
        const sum = document.createElement('div'); sum.className = 'sum';
        sum.textContent = '(no transcript yet)';

        it.appendChild(meta); it.appendChild(sum);

        // compute sessionId from THIS record
        const sessionId =
          rec.callSessionId || rec.sessionId || (rec.webex && rec.webex.callSessionId) || null;

        it.addEventListener('click', () => openDetails(rec, sessionId));
        g.appendChild(it);
      }
      wrap.appendChild(g);
    }

    async function openDetails(call) {
      // create drawer if needed
      let drawer = document.getElementById('histDrawer');
      if (!drawer) {
        drawer = document.createElement('div');
        drawer.id = 'histDrawer';
        drawer.className = 'card';
        document.getElementById('viewHist').appendChild(drawer);
      }

      // caller header stays, recordings are per-session under it
      drawer.innerHTML = `
    <div class="head">${call.caller || 'Unknown Caller'}</div>
    <div class="meta">${call.created || ''}</div>
    <div class="sum">${(call.events.find(e => e.transcript)?.transcript) || '(no local transcript yet)'}</div>
    <div id="recArea" class="group"><div class="meta">Searching recordings…</div></div>
  `;

      // determine callSessionId (recordings are linked to it)
      const sessionId =
        (call.webex && call.webex.callSessionId) ||
        (call.events.find(e => e.sessionId)?.sessionId) ||
        null;

      if (!sessionId) {
        document.querySelector('#recArea .meta').textContent = 'No session id on this call.';
        return;
      }

      // ask backend for recordings linked to this session
      const res = await fetch(`/api/calls/recordings?sessionId=${encodeURIComponent(sessionId)}`);
      if (!res.ok) {
        document.querySelector('#recArea .meta').textContent =
          'No recordings found or not authorized.';
        return;
      }
      const data = await res.json();
      if (!data.items?.length) {
        document.querySelector('#recArea .meta').textContent =
          'No recordings found for this session.';
        return;
      }

      // display all recordings for this session
      const recArea = document.getElementById('recArea');
      recArea.innerHTML = '';
      for (const r of data.items) {
        const div = document.createElement('div');
        div.className = 'recording-block';
        div.innerHTML = `
      <div class="meta">Session Recording (${r.format || 'audio'}) · ${r.durationSeconds || '?'}s</div>
      <button class="btnDl" data-id="${r.id}">Download MP3</button>
      <button class="btnTx" data-id="${r.id}">Transcribe</button>
      <div class="txOut" id="txOut-${r.id}"></div>
    `;
        recArea.appendChild(div);
      }

      recArea.querySelectorAll('.btnDl').forEach(btn => {
        btn.onclick = () => {
          const id = btn.dataset.id;
          window.open(`/api/calls/recordings/${id}/download`, '_blank');
        };
      });

      recArea.querySelectorAll('.btnTx').forEach(btn => {
        btn.onclick = async () => {
          const id = btn.dataset.id;
          const out = document.getElementById(`txOut-${id}`);
          out.textContent = 'Transcribing…';
          const t = await (await fetch(`/api/calls/recordings/${id}/transcribe`, { method: 'POST' })).json();
          out.textContent = t.text || '(empty)';
        };
      });
    }



  </script>
</body>

</html>