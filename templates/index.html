<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Placetel AI ‚Äì Call Transcripts</title>
  <script src="https://unpkg.com/@webex/embedded-app-sdk@latest"></script>
  <link rel="stylesheet" href="/static/app.css">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body class="page">
  <div class="topbar">
    <button id="tabLive" class="tab tab--active">Live</button>
    <button id="tabHist" class="tab">History</button>
    <div id="userInfo" style="margin-left: auto; color: #cfe4ff; font-size: 12px;"></div>
  </div>

  <div class="container">
    <!-- Authentication Status -->
    <div id="authStatus" class="card" style="display: none;">
      <div id="authMessage">üîê Authenticating...</div>
    </div>

    <!-- Live view -->
    <section id="viewLive" class="card">
      <header class="livehdr">
        <div class="livehdr__title" id="liveHeader"></div>
        <div class="livehdr__sub" id="liveSub"></div>
        <div class="badge">Live</div>
        <div id="liveEq" class="eq eq--hidden" aria-hidden="true">
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
        </div>
      </header>

      <!-- Transcript panel -->
      <div id="liveTx" class="tx hidden"></div>

      <!-- Idle bot -->
      <div id="liveIdle" class="empty">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div id="idleText">AI patiently waiting for calls.</div>
      </div>

      <div id="noLiveTx" class="info hidden">Warten auf Live-Transcript...</div>
    </section>

    <!-- History view -->
    <section id="viewHist" class="hidden">
      <div id="histWrap"></div>
      <div id="histEmpty" class="empty hidden">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div>No history yet‚Ä¶</div>
      </div>
    </section>
  </div>

  <script>
    // ========== AUTHENTICATION ==========
    let webexApp = null;
    let webexToken = null;
    let socket = null;
    let authenticated = false;
    let authChecked = false;
    let authAuthorized = false;

    async function checkOnce(identity) {
      if (authChecked) return authAuthorized;
      const qs = new URLSearchParams();
      if (identity.id) qs.set('id', identity.id);
      if (identity.email) qs.set('email', identity.email);
      const r = await fetch(`/auth/status?${qs.toString()}`);
      const j = await r.json();
      authChecked = true;
      authAuthorized = !!j.authorized;
      return authAuthorized;
    }

    (async function initWebex() {
      try {
        if (!window.webex || !window.webex.Application) {
          showAuthError('Webex SDK not available. Please open in Webex.');
          return;
        }

        webexApp = new window.webex.Application();
        await webexApp.onReady();
        await webexApp.listen();

        // SDK 2.x user state (email may be null under org PII policy)
        const userState = webexApp.application?.states?.user ?? {};
        const identity = {
          id: userState.id || null,
          email: userState.email || null,
          displayName: userState.displayName || null,
          number: userState.phoneNumber || null
        };
        document.getElementById('userInfo').textContent =
          identity.displayName || identity.email || identity.number || identity.id || 'User';

        // Wait briefly for OAuth to complete after redirect, then proceed
        const ok = await checkOnce(identity); //await waitForAuthorization(identity, { attempts: 10, interval: 700 });
        if (!ok) {
          showAuthorizeLink();
          return;
        }

        hideAuthStatus();
        setupCallListener();
        connectSocket(identity);   // your existing connect; emits 'authenticate' with {id,email}

      } catch (err) {
        const msg = (err && err.message) ? err.message : String(err);
        showAuthError('Failed to initialize Webex: ' + msg);
      }
    })();
    function showAuthorizeLink() {
      showAuthError('Authorization required. Click to authorize.');
      const link = document.createElement('a');
      link.href = '/oauth/login';          // server will redirect to Webex authorize and back
      link.textContent = '    Authorize Webex';
      link.style.display = 'inline-block';
      link.style.margin = '8px 0';
      document.getElementById('authMessage').appendChild(link);
    }


    function connectSocket(identity) {
      const authPayload = {
        id: (identity && typeof identity.id === 'string') ? identity.id : null,
        email: (identity && typeof identity.email === 'string') ? identity.email : null
      };

      socket = io({
        transports: ['polling'],
        upgrade: false,
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: 800
      });

      socket.on('connect', () => {
        showAuthStatus('Authenticating with Webex...');
        socket.emit('authenticate', authPayload);
      });

      socket.on('reconnect', () => {
        showAuthStatus('Reconnected. Authenticating‚Ä¶');
        socket.emit('authenticate', authPayload);
      });

      socket.on('authenticated', () => {
        authenticated = true;
        hideAuthStatus();
        if (typeof setupCallEventListener === 'function') setupCallEventListener();
      });

      socket.on('auth_failed', (data) => {
        authenticated = false;
        showAuthError('Authentication failed: ' + (data?.error || 'unknown'));
      });

      socket.on('disconnect', () => {
        authenticated = false;
        // status only; do not show the authorize link here
        showAuthStatus('Disconnected. Reconnecting‚Ä¶');
      });

      socket.on('connect_error', (err) => {
        authenticated = false;
        showAuthStatus('Connection issue: ' + (err?.message || String(err)));
      });
    }



    function showAuthStatus(message) {
      const status = document.getElementById('authStatus');
      const msg = document.getElementById('authMessage');
      msg.textContent = 'üîê ' + message;
      status.style.display = 'block';
      status.style.background = '#d1ecf1';
      status.style.color = '#0c5460';
    }

    function hideAuthStatus() {
      document.getElementById('authStatus').style.display = 'none';
    }

    function showAuthError(message) {
      const status = document.getElementById('authStatus');
      const msg = document.getElementById('authMessage');
      msg.textContent = '‚ùå ' + message;
      status.style.display = 'block';
      status.style.background = '#f8d7da';
      status.style.color = '#721c24';
    }

    function setupCallListener() {
      const lastKey = new Map();

      function getRemoteNumber(call = {}) {
        const rps = Array.isArray(call.remoteParticipants)
          ? call.remoteParticipants
          : (call.remoteParticipant ? [call.remoteParticipant] : []);

        const rp = rps[0];
        return rp?.phoneNumber || rp?.callerID || call.caller?.phoneNumber || '';
      }

      function getLocalNumber(call = {}) {
        return call.localParticipant?.phoneNumber ||
          call.localParticipant?.callerID ||
          call.to?.phoneNumber || '';
      }

      webexApp.on('sidebar:callStateChanged', (call) => {
        const state = (call?.state || '').toLowerCase();
        const remoteNumber = getRemoteNumber(call);
        const localNumber = getLocalNumber(call);
        const displayName = call.remoteParticipants?.[0]?.name || call.displayName || '';

        const key = [state, remoteNumber, localNumber].join('|');
        if (lastKey.get(call.id) === key) return;
        lastKey.set(call.id, key);

        fetch('/simulate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            event: state,
            call_id: call.id,
            remoteNumber,
            localNumber,
            displayName
          })
        }).catch((err) => {
        });
      });
    }

    // ========== UI LOGIC ==========
    const tabLive = document.getElementById('tabLive');
    const tabHist = document.getElementById('tabHist');
    const viewLive = document.getElementById('viewLive');
    const viewHist = document.getElementById('viewHist');
    const liveHeader = document.getElementById('liveHeader');
    const liveSub = document.getElementById('liveSub');
    const liveTx = document.getElementById('liveTx');
    const liveIdle = document.getElementById('liveIdle');
    const idleText = document.getElementById('idleText');
    const liveEq = document.getElementById('liveEq');
    const noLiveTx = document.getElementById('noLiveTx');

    let activeCalls = new Set();
    let hasTranscript = false;

    function showLive() {
      tabLive.classList.add('tab--active');
      tabHist.classList.remove('tab--active');
      viewLive.classList.remove('hidden');
      viewHist.classList.add('hidden');
    }

    function showHist() {
      tabHist.classList.add('tab--active');
      tabLive.classList.remove('tab--active');
      viewHist.classList.remove('hidden');
      viewLive.classList.add('hidden');
    }

    tabLive.addEventListener('click', showLive);
    tabHist.addEventListener('click', showHist);

    function escapeHtml(s) {
      return String(s ?? '').replace(/[&<>"']/g, c =>
        ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
    }

    function initStructuredCard({ name = '‚Äî', number = '‚Äî', email = '‚Äî', agent = '‚Äî' } = {}) {
      liveTx.innerHTML = `
<div class="tx-card">
<div class="tx-grid">
<div class="tx-field">
  <div class="tx-label">Kunde</div>
  <div id="fldName" class="tx-value">${escapeHtml(name)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">R√ºckrufnummer</div>
  <div id="fldNumber" class="tx-value">${escapeHtml(number)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">Email</div>
  <div id="fldEmail" class="tx-value">${escapeHtml(email)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">Agent</div>
  <div id="fldAgent" class="tx-value">${escapeHtml(agent)}</div>
</div>
<div class="tx-field tx-section">
  <div class="tx-label">Anliegen</div>
  <ul id="listConcerns" class="tx-list"></ul>
</div>
<div class="tx-field tx-section">
  <div class="tx-label">Tasks</div>
  <ul id="listTasks" class="tx-list"></ul>
</div>
</div>
</div>
`;
    }

    function setIdle(show) {
      if (show) {
        liveIdle.classList.remove('hidden');
        liveTx.classList.add('hidden');
        noLiveTx.classList.add('hidden');
        liveEq.classList.add('eq--hidden');
        liveHeader.textContent = '';
        liveSub.textContent = '';
        idleText.textContent = 'AI patiently waiting for calls.';
        hasTranscript = false;
      } else {
        liveIdle.classList.add('hidden');
      }
    }

    function addConcernLines(text) {
      if (!text || !text.trim()) return;

      const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
      const concerns = [];
      const tasks = [];
      let currentSection = null;

      for (const line of lines) {
        const lower = line.toLowerCase();
        if (lower.includes('kunde:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldName').textContent = val;
        } else if (lower.includes('r√ºckrufnummer:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldNumber').textContent = val;
        } else if (lower.includes('email:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldEmail').textContent = val;
        } else if (lower.includes('agent:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldAgent').textContent = val;
        } else if (lower === 'anliegen:') {
          currentSection = 'concerns';
        } else if (lower === 'tasks:') {
          currentSection = 'tasks';
        } else if (line.startsWith('- ')) {
          const content = line.substring(2);
          if (currentSection === 'concerns') concerns.push(content);
          else if (currentSection === 'tasks') tasks.push(content);
        }
      }

      const listConcerns = document.getElementById('listConcerns');
      const listTasks = document.getElementById('listTasks');
      if (listConcerns) {
        listConcerns.innerHTML = '';
        concerns.forEach(c => {
          const li = document.createElement('li');
          li.textContent = c;
          listConcerns.appendChild(li);
        });
      }
      if (listTasks) {
        listTasks.innerHTML = '';
        tasks.forEach(t => {
          const li = document.createElement('li');
          li.textContent = t;
          listTasks.appendChild(li);
        });
      }
    }

    function setupCallEventListener() {
      socket.on('call_event', async (p) => {
        const state = (p.state || '').toLowerCase();
        const remoteNumber = p.remoteNumber || '';
        const displayName = p.displayName || '';
        const transcript = p.transcript || '';
        const callId = p.call_id;

        liveHeader.textContent = remoteNumber || displayName || '';
        liveSub.textContent = `State: ${state}`;

        // REQ #9: Call ended - return to idle
        if (state === 'ended') {
          activeCalls.delete(callId);
          hasTranscript = false;

          if (activeCalls.size === 0) {
            setIdle(true);
          }
          return;
        }

        activeCalls.add(callId);

        // REQ #7: Ringing - show caller with idle bot
        if (state === 'ringing' || state === 'connecting') {

          liveIdle.classList.remove('hidden');
          liveEq.classList.remove('eq--hidden');
          idleText.textContent = `Incoming call from ${remoteNumber}...`;

          liveTx.classList.add('hidden');
          noLiveTx.classList.add('hidden');
          hasTranscript = false;

          return;
        }

        // REQ #8: Connected - show transcript or waiting
        if (state === 'connected') {
          if (transcript && transcript.trim()) {
            hasTranscript = true;

            liveIdle.classList.add('hidden');
            noLiveTx.classList.add('hidden');
            liveEq.classList.remove('eq--hidden');

            if (liveTx.classList.contains('hidden')) {
              initStructuredCard({
                name: displayName || '‚Äî',
                number: remoteNumber || '‚Äî',
                email: '‚Äî',
                agent: '‚Äî'
              });
            }

            liveTx.classList.remove('hidden');
            addConcernLines(transcript);

          } else {
            liveIdle.classList.add('hidden');
            liveTx.classList.add('hidden');
            liveEq.classList.remove('eq--hidden');
            noLiveTx.classList.remove('hidden');
          }
        }
      });
    }

    setIdle(true);

  </script>
</body>

</html>