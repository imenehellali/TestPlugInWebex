<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Placetel AI – Calls</title>
  <!-- head additions -->
  <script src="https://unpkg.com/@webex/embedded-app-sdk@latest"></script>
  <link rel="stylesheet" href="/static/app.css">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    /* optional quick mapping for name-over-number */
    window.CONTACTS = {
      "+4922197590844": "Imen Hellali",
      "+4930123456": "Maximilian Mustermann"
    };
  </script>
</head>
<script>
  (async function () {
    if (!window.webex || !window.webex.Application) return;
    const app = new window.webex.Application();
    await app.onReady();
    await app.listen();

    const last = new Map();
    function pickCaller(call) {
      // Try every field we’ve seen in the SDK payloads
      const c = call || {};
      return (
        c.caller?.phoneNumber ||
        c.caller?.callerID ||
        c.remoteParticipant?.callerID ||
        c.localParticipant?.callerID ||
        c.caller?.name ||
        c.remoteParticipant?.name ||
        c.displayName ||
        ''
      );
    }

    app.on('sidebar:callStateChanged', (call) => {
      const state = (call?.state || 'unknown').toLowerCase();
      if (last.get(call.id) === state) return;
      last.set(call.id, state);

      fetch('/simulate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          event: state,
          call_id: call.id,
          caller: pickCaller(call)
          // transcript: ''  // later, forward chunks if you have them
        })
      }).catch(() => { });
    });
  })();
</script>

<body class="page">
  <div class="topbar">
    <button id="tabLive" class="tab tab--active">Live</button>
    <button id="tabHist" class="tab">History</button>
  </div>

  <div class="container">
    <!-- Live view -->
    <section id="viewLive" class="card">
      <header class="livehdr">
        <div class="livehdr__title" id="liveHeader">Waiting for call…</div>
        <div class="livehdr__sub" id="liveSub">Idle</div>
        <div class="badge">Live</div>
        <div id="liveEq" class="eq eq--hidden" aria-hidden="true">
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
        </div>
      </header>

      <!-- Transcript panel -->
      <div id="liveTx" class="tx hidden"></div>
      <div id="txSkeleton" class="skeleton hidden"></div>

      <!-- Idle bot -->
      <div id="liveIdle" class="empty">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div>AI patiently waiting for calls.</div>
      </div>

      <div id="noLiveTx" class="info hidden">No live transcript yet…</div>

    </section>

    <!-- History view -->
    <section id="viewHist" class="hidden">
      <div id="histWrap"></div>
      <div id="histEmpty" class="empty hidden">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div>No history yet…</div>
      </div>
    </section>
  </div>

  <script>
    // Tabs
    const tabLive = document.getElementById('tabLive');
    const tabHist = document.getElementById('tabHist');
    const viewLive = document.getElementById('viewLive');
    const viewHist = document.getElementById('viewHist');

    function showLive() {
      tabLive.classList.add('tab--active');
      tabHist.classList.remove('tab--active');
      viewLive.classList.remove('hidden');
      viewHist.classList.add('hidden');
    }
    function showHist() {
      tabHist.classList.add('tab--active');
      tabLive.classList.remove('tab--active');
      viewHist.classList.remove('hidden');
      viewLive.classList.add('hidden');
      loadHistory();
    }
    tabLive.addEventListener('click', showLive);
    tabHist.addEventListener('click', showHist);

    // ---------- Live view ----------
    async function prettyCaller(raw) {
      if (!raw) return 'Unknown';
      if (window.CONTACTS?.[raw]) return `${window.CONTACTS[raw]} (${raw})`;

      try {
        const r = await fetch(`/api/people/lookup?number=${encodeURIComponent(raw)}`);
        if (r.ok) {
          const j = await r.json();
          if (j.displayName) return `${j.displayName} (${raw})`;
        }
      } catch (_) { }
      return raw;
    }

    const liveHeader = document.getElementById('liveHeader');
    const liveSub = document.getElementById('liveSub');
    const liveTx = document.getElementById('liveTx');
    const liveIdle = document.getElementById('liveIdle');
    const liveEq = document.getElementById('liveEq');
    const noLiveTx = document.getElementById('noLiveTx');
    const txSkeleton = document.getElementById('txSkeleton');

    let activeCalls = new Set();
    let sawLiveText = false;

    function setIdle(isIdle) {
      if (isIdle) {
        liveIdle.classList.remove('hidden');   // show bot
        liveEq.classList.add('eq--hidden');    // hide bars
        liveTx.classList.add('hidden');        // hide transcript
        txSkeleton.classList.add('hidden');
        noLiveTx.classList.add('hidden');
        liveHeader.textContent = 'Waiting for call…';
        liveSub.textContent = 'Idle';
        liveTx.textContent = '';
        sawLiveText = false;
      } else {
        liveIdle.classList.add('hidden');      // hide bot
      }
    }

    setIdle(true);

    const socket = io();

    socket.on('call_event', async (p) => {
      const state = (p.state || '').toLowerCase();

      // show number or name
      liveHeader.textContent = await prettyCaller(p.caller || p.name || p.displayName || '');

      if (state === 'ended') {
        activeCalls.delete(p.call_id);
        setIdle(activeCalls.size === 0);
        return;
      }

      // track call, but DO NOT leave idle until it's actually connected
      activeCalls.add(p.call_id);
      liveSub.textContent = `State: ${state}`;

      // show bars only during connected
      const isConnected = state === 'connected';
      liveEq.classList.toggle('eq--hidden', !isConnected);

      if (!isConnected) {
        // stay in idle view (bot visible) until pickup
        setIdle(true);
        return;
      }

      // picked up -> leave idle and show transcript placeholder immediately
      setIdle(false);

      if (p.transcript && p.transcript.trim()) {
        sawLiveText = true;
        txSkeleton.classList.add('hidden');
        noLiveTx.classList.add('hidden');
        liveTx.classList.remove('hidden');
        liveTx.textContent =
          (liveTx.textContent ? liveTx.textContent + '\n' : '') + p.transcript;
        // optional: autoscroll
        // liveTx.scrollTop = liveTx.scrollHeight;
      } else if (!sawLiveText) {
        // connected but no text yet -> show placeholder instead of idle icon
        txSkeleton.classList.add('hidden');
        liveTx.classList.add('hidden');
        noLiveTx.classList.remove('hidden');
      }
    });

    // ---------- History (robust) ----------
    async function loadHistory() {
      const wrap = document.getElementById('histWrap');
      const empty = document.getElementById('histEmpty');
      wrap.innerHTML = '';
      empty.classList.add('hidden');

      const hist = await (await fetch('/api/calls/history')).json();
      const items = hist?.items || [];
      if (!items.length) { empty.classList.remove('hidden'); return; }

      const byCaller = new Map();
      for (const rec of items) {
        const label = (rec.name && rec.name.trim()) || rec.number || 'Unknown';
        if (!byCaller.has(label)) byCaller.set(label, []);
        byCaller.get(label).push(rec);
      }

      for (const [label, arr] of byCaller.entries()) {
        const g = document.createElement('div'); g.className = 'group';
        const h = document.createElement('div'); h.className = 'head'; h.textContent = label;
        g.appendChild(h);

        arr.sort((a, b) => b.time.localeCompare(a.time));
        for (const rec of arr) {
          const it = document.createElement('div'); it.className = 'item';
          const meta = document.createElement('div'); meta.className = 'meta';
          meta.textContent = `${rec.type} | ${rec.time}`;
          const sum = document.createElement('div'); sum.className = 'sum'; sum.textContent = '(no transcript yet)';
          it.appendChild(meta); it.appendChild(sum);

          // Inline details drawer under this clicked item
          it.addEventListener('click', async () => {
            // collapse any existing drawer under this group
            const old = g.querySelector('.drawer');
            if (old) old.remove();

            const drawer = document.createElement('div');
            drawer.className = 'card drawer';
            drawer.innerHTML = `
            <div class="head">${label}</div>
            <div class="meta">${rec.type} | ${rec.time}</div>
            <div id="recMeta" class="meta">Looking for recordings…</div>
            <div style="margin-top:8px;display:flex;gap:8px;">
              <button id="btnDl" disabled>Download audio</button>
              <button id="btnTx" disabled>Transcribe & attach</button>
            </div>
            <div id="txOut" class="sum"></div>
          `;
            it.insertAdjacentElement('afterend', drawer);

            // need a session id to query recordings
            const sessionId = rec.callSessionId || rec.sessionId || null;
            if (!sessionId) {
              drawer.querySelector('#recMeta').textContent = 'No callSessionId on this record.';
              return;
            }

            const r = await fetch(`/api/calls/recordings?sessionId=${encodeURIComponent(sessionId)}`);
            if (!r.ok) { drawer.querySelector('#recMeta').textContent = 'No recordings found or not authorized.'; return; }
            const data = await r.json();
            const item = (data.items || [])[0];
            if (!item) { drawer.querySelector('#recMeta').textContent = 'No recordings for this session.'; return; }

            drawer.querySelector('#recMeta').textContent = `Recording ${item.format}, ${item.durationSeconds}s`;
            const btnDl = drawer.querySelector('#btnDl');
            const btnTx = drawer.querySelector('#btnTx');
            btnDl.disabled = btnTx.disabled = false;

            btnDl.onclick = () => window.open(`/api/calls/recordings/${item.id}/download`, '_blank');

            btnTx.onclick = async () => {
              drawer.querySelector('#txOut').textContent = 'Transcribing…';
              const t = await (await fetch(`/api/calls/recordings/${item.id}/transcribe`, { method: 'POST' })).json();
              drawer.querySelector('#txOut').textContent = t.text || '(empty)';
            };
          });

          g.appendChild(it);
        }
        wrap.appendChild(g);
      }
    }


    async function openDetails(rec, sessionId) {
      let drawer = document.getElementById('histDrawer');
      if (!drawer) {
        drawer = document.createElement('div');
        drawer.id = 'histDrawer';
        drawer.className = 'card';
        document.getElementById('viewHist').appendChild(drawer);
      }
      const title = (rec.name && rec.name.trim()) || rec.number || 'Unknown Caller';
      drawer.innerHTML = `
    <div class="head">${title}</div>
    <div class="meta">${rec.type || ''} | ${rec.time || ''}</div>
    <div class="sum">(no local transcript)</div>
    <div id="recArea" class="group"><div class="meta">Searching recordings…</div></div>
  `;

      if (!sessionId) {
        document.querySelector('#recArea .meta').textContent = 'No callSessionId on this record.';
        return;
      }

      // Use the correct backend path you created for Converged Recordings:
      const q = new URLSearchParams({ sessionId });
      const res = await fetch(`/api/recordings/search?${q}`, { cache: 'no-store' });
      if (!res.ok) {
        document.querySelector('#recArea .meta').textContent = 'No recordings or not authorized.';
        return;
      }
      const data = await res.json();
      if (!data.items || !data.items.length) {
        document.querySelector('#recArea .meta').textContent = 'No recordings for this session.';
        return;
      }

      const recArea = document.getElementById('recArea');
      recArea.innerHTML = '';
      for (const r of data.items) {
        const div = document.createElement('div');
        div.className = 'recording-block';
        div.innerHTML = `
      <div class="meta">Recording: ${(r.format || 'audio')} · ${(r.durationSeconds || '?')}s</div>
      <button class="btnDl" data-id="${r.id}">Download MP3</button>
      <button class="btnTx" data-id="${r.id}">Transcribe</button>
      <div class="txOut" id="txOut-${r.id}"></div>
    `;
        recArea.appendChild(div);
      }

      recArea.querySelectorAll('.btnDl').forEach(btn => {
        btn.onclick = () => {
          const id = btn.dataset.id;
          window.open(`/api/recordings/${id}/download`, '_blank');
        };
      });
      recArea.querySelectorAll('.btnTx').forEach(btn => {
        btn.onclick = async () => {
          const id = btn.dataset.id;
          const out = document.getElementById(`txOut-${id}`);
          out.textContent = 'Transcribing…';
          const t = await (await fetch(`/api/recordings/${id}/transcribe`, { method: 'POST' })).json();
          out.textContent = t.text || '(empty)';
        };
      });
    }

  </script>
</body>

</html>