<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Placetel AI ‚Äì Secure Calls</title>
  <script src="https://unpkg.com/@webex/embedded-app-sdk@latest"></script>
  <link rel="stylesheet" href="/static/app.css">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body class="page">
  <div class="topbar">
    <button id="tabLive" class="tab tab--active">Live</button>
    <button id="tabHist" class="tab">History</button>
    <div id="userInfo" style="margin-left: auto; color: #cfe4ff; font-size: 12px;"></div>
  </div>

  <div class="container">
    <!-- Authentication Status -->
    <div id="authStatus" class="card" style="display: none;">
      <div id="authMessage">üîê Authenticating...</div>
    </div>

    <!-- Live view -->
    <section id="viewLive" class="card">
      <header class="livehdr">
        <div class="livehdr__title" id="liveHeader"></div>
        <div class="livehdr__sub" id="liveSub"></div>
        <div class="badge">Live</div>
        <div id="liveEq" class="eq eq--hidden" aria-hidden="true">
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
          <div class="eq__bar"></div>
        </div>
      </header>

      <!-- Transcript panel -->
      <div id="liveTx" class="tx hidden"></div>

      <!-- Idle bot -->
      <div id="liveIdle" class="empty">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div>AI patiently waiting for calls.</div>
      </div>

      <div id="noLiveTx" class="info hidden">Warten auf Live-Transcript...</div>
    </section>

    <!-- History view -->
    <section id="viewHist" class="hidden">
      <div id="histWrap"></div>
      <div id="histEmpty" class="empty hidden">
        <img class="pulse" src="/static/bot.png" alt="AI bot">
        <div>No history yet‚Ä¶</div>
      </div>
    </section>
  </div>

  <script>
    // ========== SECURE AUTHENTICATION ==========
    let webexApp = null;
    let webexUser = null;
    let webexToken = null;
    let socket = null;
    let authenticated = false;

    // Initialize Webex SDK and authenticate
    (async function initWebex() {
      try {
        console.log('üîê Initializing Webex SDK...');
       
        if (!window.webex || !window.webex.Application) {
          console.error('‚ùå Webex SDK not loaded');
          showAuthError('Webex SDK not available. Please open in Webex.');
          return;
        }

        webexApp = new window.webex.Application();
        await webexApp.onReady();
        await webexApp.listen();
       
        console.log('‚úÖ Webex SDK ready');

        // Get user context
        try {
          const context = await webexApp.context.getUser();
          webexUser = context;
          console.log('‚úÖ User context:', context.email || context.id);
         
          // Update UI with user info
          document.getElementById('userInfo').textContent =
            `üë§ ${context.displayName || context.email || 'User'}`;
         
        } catch (e) {
          console.warn('‚ö†Ô∏è Could not get user context:', e);
        }

        // Get access token
        try {
  webexToken = await webexApp.context.getAccessToken();
} catch (e) {
  console.warn('‚ö†Ô∏è Could not get Webex token (dev mode), continuing anyway');
  webexToken = 'dev-token';
}


        // Connect to Socket.IO and authenticate
        connectSocket();

        // Listen for call events
        setupCallListener();

      } catch (error) {
        console.error('‚ùå Webex init error:', error);
        showAuthError('Failed to initialize Webex: ' + error.message);
      }
    })();

    function connectSocket() {
      console.log('üîå Connecting to Socket.IO...');
     
      const socket = io("https://servantlike-thermochemically-maison.ngrok-free.dev", {
  transports: ["websocket"]
});


      socket.on('connect', () => {
        console.log('üîå Socket connected, authenticating...');
        showAuthStatus('Authenticating with Webex...');
       
        // Authenticate with Webex token
        socket.emit('authenticate', {
          webex_access_token: webexToken
        });
      });

      socket.on('authenticated', (data) => {
        console.log('‚úÖ Authenticated as:', data.user_email);
        authenticated = true;
        hideAuthStatus();
       
        // Now listen for call events
        setupCallEventListener();
      });

      socket.on('auth_failed', (data) => {
        console.error('‚ùå Authentication failed:', data.error);
        showAuthError('Authentication failed: ' + data.error);
      });

      socket.on('disconnect', () => {
        console.log('üîå Socket disconnected');
        authenticated = false;
        showAuthStatus('Disconnected. Reconnecting...');
      });

      socket.on('connect_error', (error) => {
        console.error('‚ùå Connection error:', error);
        showAuthError('Connection failed: ' + error.message);
      });
    }

    function showAuthStatus(message) {
      const status = document.getElementById('authStatus');
      const msg = document.getElementById('authMessage');
      msg.textContent = 'üîê ' + message;
      status.style.display = 'block';
    }

    function hideAuthStatus() {
      document.getElementById('authStatus').style.display = 'none';
    }

    function showAuthError(message) {
      const status = document.getElementById('authStatus');
      const msg = document.getElementById('authMessage');
      msg.textContent = '‚ùå ' + message;
      status.style.display = 'block';
      status.style.background = '#f8d7da';
      status.style.color = '#721c24';
    }

    function setupCallListener() {
      const lastKey = new Map();

      function getRemoteNumber(call = {}) {
        const rps = Array.isArray(call.remoteParticipants)
          ? call.remoteParticipants
          : (call.remoteParticipant ? [call.remoteParticipant] : []);
       
        const rp = rps[0];
        return rp?.phoneNumber || rp?.callerID || call.caller?.phoneNumber || '';
      }

      function getLocalNumber(call = {}) {
        return call.localParticipant?.phoneNumber ||
               call.localParticipant?.callerID ||
               call.to?.phoneNumber || '';
      }

      webexApp.on('sidebar:callStateChanged', (call) => {
        const state = (call?.state || '').toLowerCase();
        const remoteNumber = getRemoteNumber(call);
        const localNumber = getLocalNumber(call);
        const displayName = call.remoteParticipants?.[0]?.name || call.displayName || '';

        const key = [state, remoteNumber, localNumber].join('|');
        if (lastKey.get(call.id) === key) return;
        lastKey.set(call.id, key);

        console.log(`üìû Call ${state}: remote=${remoteNumber}, local=${localNumber}`);

        fetch('/simulate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            event: state,
            call_id: call.id,
            remoteNumber,
            localNumber,  // CRITICAL: User's own number
            displayName
          })
        }).catch((err) => {
          console.error('‚ùå Failed to send call event:', err);
        });
      });
    }

    // ========== UI LOGIC ==========
    const tabLive = document.getElementById('tabLive');
    const tabHist = document.getElementById('tabHist');
    const viewLive = document.getElementById('viewLive');
    const viewHist = document.getElementById('viewHist');
    const liveHeader = document.getElementById('liveHeader');
    const liveSub = document.getElementById('liveSub');
    const liveTx = document.getElementById('liveTx');
    const liveIdle = document.getElementById('liveIdle');
    const liveEq = document.getElementById('liveEq');
    const noLiveTx = document.getElementById('noLiveTx');

    let activeCalls = new Set();
    let hasTranscript = false;

    function showLive() {
      tabLive.classList.add('tab--active');
      tabHist.classList.remove('tab--active');
      viewLive.classList.remove('hidden');
      viewHist.classList.add('hidden');
    }

    function showHist() {
      tabHist.classList.add('tab--active');
      tabLive.classList.remove('tab--active');
      viewHist.classList.remove('hidden');
      viewLive.classList.add('hidden');
      loadHistory();
    }

    tabLive.addEventListener('click', showLive);
    tabHist.addEventListener('click', showHist);

    function escapeHtml(s) {
      return String(s ?? '').replace(/[&<>"']/g, c =>
        ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'}[c]));
    }

    function initStructuredCard({ name = '‚Äî', number = '‚Äî', email = '‚Äî', agent = '‚Äî' } = {}) {
      liveTx.innerHTML = `
<div class="tx-card">
<div class="tx-grid">
<div class="tx-field">
  <div class="tx-label">Kunde</div>
  <div id="fldName" class="tx-value">${escapeHtml(name)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">R√ºckrufnummer</div>
  <div id="fldNumber" class="tx-value">${escapeHtml(number)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">Email</div>
  <div id="fldEmail" class="tx-value">${escapeHtml(email)}</div>
</div>
<div class="tx-field">
  <div class="tx-label">Agent</div>
  <div id="fldAgent" class="tx-value">${escapeHtml(agent)}</div>
</div>
<div class="tx-field tx-section">
  <div class="tx-label">Anliegen</div>
  <ul id="listConcerns" class="tx-list"></ul>
</div>
<div class="tx-field tx-section">
  <div class="tx-label">Tasks</div>
  <ul id="listTasks" class="tx-list"></ul>
</div>
</div>
</div>
`;
    }

    function setIdle(show) {
      if (show) {
        liveIdle.classList.remove('hidden');
        liveTx.classList.add('hidden');
        noLiveTx.classList.add('hidden');
        liveEq.classList.add('eq--hidden');
        liveHeader.textContent = '';
        liveSub.textContent = '';
        hasTranscript = false;
      } else {
        liveIdle.classList.add('hidden');
      }
    }

    function addConcernLines(text) {
      if (!text || !text.trim()) return;

      const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
      const concerns = [];
      const tasks = [];
      let currentSection = null;

      for (const line of lines) {
        const lower = line.toLowerCase();
        if (lower.includes('kunde:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldName').textContent = val;
        } else if (lower.includes('r√ºckrufnummer:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldNumber').textContent = val;
        } else if (lower.includes('email:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldEmail').textContent = val;
        } else if (lower.includes('agent:')) {
          const val = line.split(':')[1]?.trim();
          if (val) document.getElementById('fldAgent').textContent = val;
        } else if (lower === 'anliegen:') {
          currentSection = 'concerns';
        } else if (lower === 'tasks:') {
          currentSection = 'tasks';
        } else if (line.startsWith('- ')) {
          const content = line.substring(2);
          if (currentSection === 'concerns') concerns.push(content);
          else if (currentSection === 'tasks') tasks.push(content);
        }
      }

      const listConcerns = document.getElementById('listConcerns');
      const listTasks = document.getElementById('listTasks');
      if (listConcerns) {
        listConcerns.innerHTML = '';
        concerns.forEach(c => {
          const li = document.createElement('li');
          li.textContent = c;
          listConcerns.appendChild(li);
        });
      }
      if (listTasks) {
        listTasks.innerHTML = '';
        tasks.forEach(t => {
          const li = document.createElement('li');
          li.textContent = t;
          listTasks.appendChild(li);
        });
      }
    }

    function setupCallEventListener() {
      socket.on('call_event', async (p) => {
        console.log('üìû Call event received:', p.state, p.remoteNumber);
       
        const state = (p.state || '').toLowerCase();
        const remoteNumber = p.remoteNumber || p.caller || '';
        const displayName = p.displayName || '';
        const transcript = p.transcript || '';
        const callId = p.call_id;

        // Update header
        liveHeader.textContent = remoteNumber || displayName || '';
        liveSub.textContent = `State: ${state}`;

        // Show/hide equalizer
        const isConnected = state === 'connected';
        liveEq.classList.toggle('eq--hidden', !isConnected);

        // Handle call end
        if (state === 'ended' || state === 'completed' || state === 'hangup') {
          console.log('‚òéÔ∏è Call ended');
          activeCalls.delete(callId);
          hasTranscript = false;
         
          if (activeCalls.size === 0) {
            setIdle(true);
          }
          return;
        }

        // Track active call
        activeCalls.add(callId);

        // Show transcript if available
        if (transcript && transcript.trim()) {
          console.log('‚úÖ Transcript received');
          hasTranscript = true;
         
          liveIdle.classList.add('hidden');
          noLiveTx.classList.add('hidden');
         
          if (liveTx.classList.contains('hidden')) {
            initStructuredCard({
              name: displayName || '‚Äî',
              number: remoteNumber || '‚Äî',
              email: '‚Äî',
              agent: '‚Äî'
            });
          }
         
          liveTx.classList.remove('hidden');
          addConcernLines(transcript);
        } else if (isConnected && !hasTranscript) {
          liveIdle.classList.add('hidden');
          liveTx.classList.add('hidden');
          noLiveTx.classList.remove('hidden');
        } else if (!isConnected) {
          liveIdle.classList.add('hidden');
          liveTx.classList.add('hidden');
          noLiveTx.classList.add('hidden');
        }
      });
    }

    async function loadHistory() {
      // History loading logic (unchanged)
      const wrap = document.getElementById('histWrap');
      const empty = document.getElementById('histEmpty');
      wrap.innerHTML = '<div>Loading history...</div>';
      empty.classList.add('hidden');
    }

    // Initial state
    setIdle(true);

  </script>
</body>
</html>

